.model small
.stack 100h

.data
    prompt db 'Enter a number (up to 1000): $'  ; Строка для запроса ввода
    result db 'The square is: $'                  ; Строка для вывода квадрата числа
    newline db 13, 10, '$'                        ; Символы для новой строки (CR, LF)
    buffer db 5, ?, 0                             ; Буфер для ввода (максимум 4 цифры + 1 для нуля)

.code
main:
    ; Инициализация сегмента данных
    mov ax, @data
    mov ds, ax

    ; Печать запроса
    mov ah, 09h
    lea dx, prompt
    int 21h

    ; Считывание строки (до 4 символов для числа)
    lea dx, buffer
    mov ah, 0Ah         ; Функция для ввода строки
    int 21h

    ; Преобразуем строку в число
    lea si, buffer + 2  ; Указатель на первые символы числа (после длины строки и начального символа)
    xor ax, ax          ; Обнуляем AX, он будет содержать число
convert_loop:
    mov al, [si]        ; Загружаем текущий символ
    cmp al, 0           ; Проверяем, не конец строки ли
    je done_convert     ; Если конец строки, выходим
    sub al, '0'         ; Преобразуем символ в число
    imul ax, ax, 10     ; Умножаем результат на 10 (сдвиг на разряд)
    add ax, al          ; Прибавляем текущую цифру
    inc si              ; Переходим к следующему символу
    jmp convert_loop

done_convert:
    ; Вычисление квадрата числа
    mov bx, ax          ; Копируем число в BX
    imul bx             ; AX = AX * AX (AX теперь содержит квадрат числа)

    ; Печать новой строки (перенос на новую строку)
    mov ah, 09h
    lea dx, newline
    int 21h

    ; Печать строки "The square is:"
    mov ah, 09h
    lea dx, result
    int 21h

    ; Печать квадрата числа
    ; Для вывода квадрата нужно преобразовать число обратно в строку
    ; Число в AX нужно конвертировать в строку
    call PrintNumber

    ; Печать новой строки (перенос на новую строку)
    mov ah, 09h
    lea dx, newline
    int 21h

    ; Завершение программы
    mov ah, 4Ch
    int 21h

; Подпрограмма для вывода числа
PrintNumber:
    push ax            ; Сохраняем AX
    push bx            ; Сохраняем BX

    mov cx, 10         ; Основание системы счисления
    lea di, buffer + 5 ; Указатель на конец буфера (будем записывать цифры в обратном порядке)
    mov byte ptr [di], 0  ; Завершающий нулевой символ
    dec di

    ; Преобразование числа в строку
convert_to_str:
    xor dx, dx            ; Обнуляем DX
    div cx                ; AX делим на 10, результат в AX, остаток в DX
    add dl, '0'           ; Преобразуем остаток в символ
    mov [di], dl          ; Записываем символ в буфер
    dec di                ; Переходим к предыдущей позиции в буфере
    test ax, ax           ; Если AX = 0, завершили
    jnz convert_to_str    ; Иначе продолжаем

    ; Печать числа
    lea dx, buffer + 1    ; Указываем на начало строки (игнорируем первый байт с длиной)
    mov ah, 09h
    int 21h

    pop bx                ; Восстанавливаем BX
    pop ax                ; Восстанавливаем AX
    ret

